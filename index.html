<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GImage - 按需生成图片</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        body {
            text-align: center;
        }

        .line {
            margin-bottom: 8px;
        }

        .button {
            cursor: pointer;
        }

        #file {
            display: none;
        }
    </style>
</head>
<body>
    <div class="line">
        <label for="width">宽</label>
        <input id="width" type="number" min="10" max="500" value="300" placeholder="请输入数字" />
        <label for="height">高</label>
        <input id="height" type="number" min="10" max="500" value="300" placeholder="请输入数字" />
        <label for="suffix">格式</label>
        <select id="suffix"></select>
        <label for="color">颜色</label>
        <input id="color" type="color" />
        <input id="watermark" type="checkbox" />
        <label for="watermark" >水印</label>
    </div>

    <div class="line">
        <label for="file" class="button">上传图片</label>
        <input id="file" type="file" accept=".png,.jpg,.jpeg" />
        <span class="button" onclick="deleteImage()">清除图片</span>
    </div>

    <div class="line">
        <!-- <span> -->
            <span id="preview" class="button" onclick="preview()">预览</span>
        <!-- </span> -->

    </div>

    <div class="line">
        <canvas id="myCanvas" width="300" height="300">
            如果你的页面展示了这句话，说明你的浏览器不支持canvas
        </canvas>
    </div>

    <div>
        <i class="icon-tupian"></i>
        <a id="download" href="">下载</a>
    </div>

    <script>
        // Q: 如何实现图片下载
        // A: 使用a标签加download属性实现下载

        // Q: 如何循环平铺输出水印（满屏水印）
        // A: 根据长宽的平方根计算打印水印的行数与个数

        // Q: 如何将上传的图片绘制到canvas上（Failed to execute 'drawImage' on 'CanvasRenderingContext2D）
        // A: 绘制时只能绘制image元素(new Image), 而不能绘制 image 的 base64 字符串

        // Q: 绘制图片时，如何处理image onload事件异步的问题（我需要在图片绘制完毕之后才能将canvas导出成下载链接放到a标签上）
        // A: 剥离异步操作，在 image onload 完毕后再调用 draw 方法，而不是在 draw 方法里面去加载图片（懒得用Promise）

        // Q: 如何修改图片质量（压缩或增大）
        // A: toDataURL 的第二个参数



        // 非必要，元素ID会自动在全局（window）下生成同名变量，无需再获取DOM
        // 此处获取DOM为了便于理解
        var widthDom = document.getElementById('width')
        var heightDom = document.getElementById('height')
        var suffixDom = document.getElementById('suffix')
        var colorDom = document.getElementById('color')
        var watermarkDom = document.getElementById('watermark')
        var fileDom = document.getElementById('file')
        var downloadDom = document.getElementById('download')

        var canvas = document.getElementById('myCanvas')
        var ctx = canvas.getContext('2d');

        var currentWidth = width = 300;
        var currentHeight = height = 300;

        // NOTE: <input type="color" /> 其 value 值必须为 #rrggbb 格式
        var brushColor = '#eeeeee';

        var pictureName = 'GImage'
        var options = ['png', 'jpg', 'jpeg']
        var optionIndex = 0;

        // 保存用于绘制的图片
        var image = null;

        widthDom.oninput = function(e) {
            reset('currentWidth', e.target.value)
        }

        heightDom.oninput = function(e) {
            reset('currentHeight', e.target.value)
        }

        suffixDom.onchange = function() {
            optionIndex = suffixDom.selectedIndex;
        }

        colorDom.onchange = function() {
            brushColor = colorDom.value;
        }

        fileDom.onchange = function() {
            console.log(fileDom.files)
            const file = fileDom.files[0];
            if (!file) {
                return;
            }

            if(!/image\/\w+/.test(file.type)){
                alert("请确保文件为图像类型");
                return;
            }

            var fileReader = new FileReader();
            fileReader.readAsDataURL(file)
            fileReader.onload = function(e) {
                image = new Image();
                image.onload = function() {
                    draw()
                }
                image.src = fileReader.result;
            }
        }

        function reset(field, value) {
            window[field] = Number(value);
        }

        function clear() {
            ctx.clearRect(0, 0, width, height)
        }

        // 绘制图片
        function draw() {
            canvas.width = width = currentWidth;
            canvas.height = height = currentHeight;

            if (image) {
                // 绘制图片
                ctx.drawImage(image, 0, 0, width, height)
            }
            else {
                // 绘制矩形
                ctx.fillStyle = brushColor
                ctx.fillRect(0, 0, width, height)
            }

            // 添加水印
            if (watermarkDom.checked) {
                ctx.strokeStyle = '#d2cfcf'
                ctx.font = "30px sans-serif"
                ctx.rotate((-45 * Math.PI) / 180);

                var strokeNum = Math.ceil(Math.sqrt(height * height + width * width) / 30) + 1
                for (let i = 0; i < strokeNum; i++) {
                    for (let j = -(strokeNum / 2); j < (strokeNum / 2); j++) {
                        ctx.strokeText("GImage", -120 * j, i * 50);
                    }
                }
            }

            // 生成图片
            var suffix = options[optionIndex];
            downloadDom.href = canvas.toDataURL(`image/${suffix}`);
            downloadDom.download = `${pictureName}.${suffix}`
        }

        // 图片预览
        function preview() {
            clear()
            draw();
        }

        function deleteImage() {
            if (image) {
                image = null;
                draw()
            }
        }

        // 初始化图片后缀列表
        function initOptions() {
            var html = '';
            options.forEach(option => {
                html += `<option label="${option}"></option>`;
            });
            suffixDom.innerHTML = html;
        }

        // 初始化画笔颜色
        function initBrushColor() {
            colorDom.setAttribute('value', brushColor)
        }

        // 全局初始化
        function init() {
            initOptions();
            initBrushColor();
            draw();
        }

        init()
    </script>
</body>
</html>